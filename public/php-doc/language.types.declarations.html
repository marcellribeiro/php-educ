<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Declara&ccedil;&otilde;es de tipo</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.types.iterable.html">« Iter&aacute;veis</a></li>
      <li style="float: right;"><a href="language.types.type-juggling.html">Convers&atilde;o autom&aacute;tica de tipos »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="/">PHP-HELP</a></li><li><a href="/php-doc/">Manual</a></li>
    <li><a href="language.types.html">Tipos</a></li>
    <li>Declara&ccedil;&otilde;es de tipo</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.types.declarations" class="sect1">
 <h2 class="title">Declarações de tipo</h2>

 <p class="para">
  As declarações de tipo podem ser adicionadas a argumentos de função, valores de retorno e,
  a partir do PHP 7.4.0, propriedades de classe. Eles garantem que o valor
  seja do tipo especificado no momento da chamada, caso contrário, um
  <span class="classname"><a href="class.typeerror.html" class="classname">TypeError</a></span> é lançado.
 </p>

 <p class="para">
  Cada tipo que o PHP suporta, com exceção de
  <span class="type">resource</span>, pode ser usado dentro de uma declaração de tipo de usuário.
  Esta página contém um changelog de disponibilidade dos diferentes tipos
  e documentação sobre o uso deles em declarações de tipo.
 </p>

 <blockquote class="note"><p><strong class="note">Nota</strong>: 
  <p class="para">
   Quando uma classe implementa um método de interface ou reimplementa um método
   já definido por uma classe pai, ela deve ser compatível com a
   definição acima.
   Um método é compatível se segue as
   regras de <a href="language.oop5.variance.html" class="link">variância</a>.
  </p>
 </p></blockquote>

 <div class="sect2">
  <h3 class="title">Changelog</h3>
  <table class="doctable informaltable">
   
    <thead>
     <tr>
      <th>Versão</th>
      <th>Descrição</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>8.2.0</td>
      <td>
       O suporte para tipos <abbr title="Disjunctive Normal Form">DNF</abbr> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.2.0</td>
      <td>
       O suporte para o tipo literal <span class="type"><span class="type true">true</span></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.2.0</td>
      <td>
       Os tipos <span class="type">null</span> e <span class="type"><span class="type false">false</span></span> agora podem ser usados de forma independente.
      </td>
     </tr>

     <tr>
      <td>8.1.0</td>
      <td>
       O suporte para tipos de interseção foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.1.0</td>
      <td>
       Retornar por referência de uma função <span class="type"><span class="type void">void</span></span> agora está obsoleto.
      </td>
     </tr>

     <tr>
      <td>8.1.0</td>
      <td>
       O suporte para o tipo somente retorno <span class="type"><span class="type never">never</span></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.0.0</td>
      <td>
       O suporte para <span class="type"><a href="language.types.declarations.html#language.types.declarations.mixed" class="type mixed">mixed</a></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.0.0</td>
      <td>
       O suporte para o tipo de retorno apenas <span class="type"><span class="type static">static</span></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>8.0.0</td>
      <td>
       O suporte para tipos de união foi adicionado.
      </td>
     </tr>

     <tr>
      <td>7.2.0</td>
      <td>
       Suporte para <span class="type">object</span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>7.1.0</td>
      <td>
       Suporte para <span class="type"><a href="language.types.iterable.html" class="type iterable">iterable</a></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>7.1.0</td>
      <td>
       Suporte para <span class="type"><span class="type void">void</span></span> foi adicionado.
      </td>
     </tr>

     <tr>
      <td>7.1.0</td>
      <td>
       O suporte para tipos anuláveis foi adicionado.
      </td>
     </tr>

    </tbody>
   
  </table>

 </div>

 <div class="sect2" id="language.types.declarations.base">
  <h3 class="title">Tipos Base Notas de Uso</h3>

  <p class="simpara">
   Os tipos básicos têm um comportamento direto com algumas ressalvas menores que
   são descritas nesta seção.
  </p>

  <div class="sect3" id="language.types.declarations.base.scalar">
   <h4 class="title">Tipos escalares</h4>
   <div class="warning"><strong class="warning">Aviso</strong>
    <p class="para">
     Aliases de nome para tipos escalares (<span class="type">bool</span>, <span class="type">int</span>,
     <span class="type">float</span>, <span class="type">string</span>) não são suportados.
     Em vez disso, eles são tratados como nomes de classe ou interface.
     Por exemplo, usar <code class="literal">boolean</code> como uma declaração
     de tipo exigirá que o valor seja uma <a href="language.operators.type.html" class="link"><code class="literal">instanceof</code></a> da classe ou interface
     <code class="literal">boolean</code>, em vez do tipo <span class="type">bool</span>:
    </p>
    <div class="example" id="example-74">
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />    </span><span style="color: #007700">function </span><span style="color: #0000BB">test</span><span style="color: #007700">(</span><span style="color: #0000BB">boolean $param</span><span style="color: #007700">) {}<br />    </span><span style="color: #0000BB">test</span><span style="color: #007700">(</span><span style="color: #0000BB">true</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>Saída do exemplo acima no PHP 8:</p></div>
     <div class="example-contents screen">
<div class="cdata"><pre>
Warning: &quot;boolean&quot; will be interpreted as a class name. Did you mean &quot;bool&quot;? Write &quot;\boolean&quot; to suppress this warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
  thrown in - on line 2
</pre></div>
     </div>
    </div>
   </div>
  </div>

  <div class="sect3" id="language.types.declarations.void">
   <h4 class="title">void</h4>
   <blockquote class="note"><p><strong class="note">Nota</strong>: 
    <p class="para">
     Retornar por referência de uma função <span class="type"><span class="type void">void</span></span> está obsoleto a partir do PHP 8.1.0,
     porque tal função é contraditória.
     Anteriormente, ele já emitia o seguinte
     <strong><code>E_NOTICE</code></strong> quando chamado:
     <code class="literal">Somente referências de variáveis devem ser retornadas por referência</code>.

     <div class="informalexample">
      <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function &amp;</span><span style="color: #0000BB">test</span><span style="color: #007700">(): </span><span style="color: #0000BB">void </span><span style="color: #007700">{}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
      </div>

     </div>
    </p>
   </p></blockquote>
  </div>

  <div class="sect3" id="language.types.declarations.base.function">
   <h4 class="title">Tipos que podem ser chamados</h4>
   <p class="para">
    Este tipo não pode ser usado como uma declaração de tipo de propriedade de classe.
   </p>

   <blockquote class="note"><p><strong class="note">Nota</strong>: 
    <span class="simpara">
     Não é possível especificar a assinatura da função.
    </span>
   </p></blockquote>
  </div>

  <div class="sect3" id="language.types.declarations.references">
   <h4 class="title">Declarações de tipo em parâmetros de passagem por referência</h4>

   <p class="simpara">
    Se um parâmetro de passagem por referência tiver uma declaração de tipo, o tipo da
    variável só é verificado na entrada da função, no início da chamada, mas não
    quando a função retorna.
    Isso significa que uma função pode alterar o tipo de referência de variável.
   </p>
   <div class="example" id="example-75">
    <p><strong>Exemplo #1 Parâmetros de passagem por referência digitados</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">array_baz</span><span style="color: #007700">(array &amp;</span><span style="color: #0000BB">$param</span><span style="color: #007700">)<br />{<br />    </span><span style="color: #0000BB">$param </span><span style="color: #007700">= </span><span style="color: #0000BB">1</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">$var </span><span style="color: #007700">= [];<br /></span><span style="color: #0000BB">array_baz</span><span style="color: #007700">(</span><span style="color: #0000BB">$var</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$var</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">array_baz</span><span style="color: #007700">(</span><span style="color: #0000BB">$var</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>O exemplo acima produzirá
algo semelhante a:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
  thrown in - on line 2
</pre></div>
    </div>
   </div>
  </div>
 </div>

 <div class="sect2" id="language.types.declarations.composite">
  <h3 class="title">Notas de Uso de Tipos Compostos</h3>
  <p class="para">
   As declarações de tipo composto estão sujeitas a algumas restrições e
   realizarão uma verificação de redundância no tempo de compilação para evitar erros simples.
  </p>

  <div class="caution"><strong class="caution">Cuidado</strong>
   <p class="simpara">
    Antes do PHP 8.2.0 e da introdução dos tipos <abbr title="Disjunctive Normal Form">DNF</abbr>,
    não era possível combinar tipos de interseção com tipos de união.
   </p>
  </div>

  <div class="sect3" id="language.types.declarations.composite.union">
   <h4 class="title">Uniao de tipos</h4>
   <div class="warning"><strong class="warning">Aviso</strong>
    <p class="simpara">
     Não é possível combinar os dois tipos literais <span class="type"><span class="type false">false</span></span>
     e <span class="type"><span class="type true">true</span></span> juntos em um tipo de união.
     Em vez disso, use <span class="type">bool</span>.
    </p>
   </div>

   <div class="caution"><strong class="caution">Cuidado</strong>
    <p class="simpara">
     Antes do PHP 8.2.0, como <span class="type"><span class="type false">false</span></span> e <span class="type">null</span>
     não podiam ser usados como tipos autônomos, um tipo de união composto
     apenas por esses tipos não era permitido. Isso inclui os seguintes tipos:
     <span class="type"><span class="type false">false</span></span>, <code class="literal">false|null</code>,
     e <code class="literal">?false</code>.
    </p>
   </div>

   <div class="sect4" id="language.types.declarations.nullable">
    <h5 class="title">Açúcar sintático de tipo anulável</h5>

    <p class="para">
     Uma única declaração de tipo base pode ser marcada como anulável prefixando o
     tipo com um ponto de interrogação (<code class="literal">?</code>).
     Assim, <code class="literal">?T</code> e <code class="literal">T|null</code> são idênticos.
    </p>

    <blockquote class="note"><p><strong class="note">Nota</strong>: 
     <span class="simpara">
      Esta sintaxe é suportada a partir do PHP 7.1.0, e é anterior ao suporte generalizado
      de tipos de união.
     </span>
    </p></blockquote>

    <blockquote class="note"><p><strong class="note">Nota</strong>: 
     <p class="para">
      Também é possível obter argumentos anuláveis tornando
      <code class="literal">null</code>  o valor padrão.
      Isso não é recomendado, pois se o valor padrão for alterado em uma classe
      filha, uma violação de compatibilidade de tipo será gerada, pois o tipo
      <span class="type">null</span> precisará ser adicionado à declaração de tipo.
     </p>
     <div class="example" id="example-76">
      <p><strong>Exemplo #2 Maneira antiga de tornar os argumentos anuláveis</strong></p>
      <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">C </span><span style="color: #007700">{}<br /><br />function </span><span style="color: #0000BB">f</span><span style="color: #007700">(</span><span style="color: #0000BB">C $c </span><span style="color: #007700">= </span><span style="color: #0000BB">null</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$c</span><span style="color: #007700">);<br />}<br /><br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">C</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(</span><span style="color: #0000BB">null</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
      </div>

      <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
      <div class="example-contents screen">
<div class="cdata"><pre>
object(C)#1 (0) {
}
NULL
</pre></div>
      </div>
     </div>
    </p></blockquote>
   </div>
  </div>

  <div class="sect3" id="language.types.declarations.composite.redundant">
   <h4 class="title">Tipos duplicados e redundantes</h4>
   <p class="para">
    Para capturar bugs simples em declarações de tipo composto, tipos redundantes que
    podem ser detectados sem executar o carregamento de classe resultarão em um
    erro de tempo de compilação. Isso inclui:

    <ul class="itemizedlist">
     <li class="listitem">
      <span class="simpara">
       Cada tipo resolvido por nome pode ocorrer apenas uma vez. Tipos como
       <code class="literal">int|string|INT</code> ou
       <code class="literal">Countable&amp;Traversable&amp;COUNTABLE</code>
       resultam em erro.
      </span>
     </li>
     <li class="listitem">
      <span class="simpara">
       O uso <span class="type"><a href="language.types.declarations.html#language.types.declarations.mixed" class="type mixed">mixed</a></span> resulta em erro.
      </span>
     </li>
     <li class="listitem">
      <span class="simpara">Para tipos de união:</span>
      <ul class="itemizedlist">
       <li class="listitem">
        <span class="simpara">
         Se <span class="type">bool</span> for usado, <span class="type"><span class="type false">false</span></span> ou <span class="type"><span class="type true">true</span></span>
         não pode ser usado adicionalmente.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         Se <span class="type">object</span> for usado, os tipos de classe não podem ser usados adicionalmente.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         Se <span class="type"><a href="language.types.iterable.html" class="type iterable">iterable</a></span> for usado, <span class="type">array</span>
         e <span class="classname"><a href="class.traversable.html" class="classname">Traversable</a></span> não podem ser usados adicionalmente.
        </span>
       </li>
      </ul>
     </li>
     <li class="listitem">
      <span class="simpara">Para interseção de tipos:</span>
      <ul class="itemizedlist">
       <li class="listitem">
        <span class="simpara">
         Usar um tipo que não é um tipo de classe resulta em erro.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         O uso de <span class="type"><span class="type self">self</span></span>, <span class="type"><span class="type parent">parent</span></span> ou
         <span class="type"><span class="type static">static</span></span> resulta em erro.
        </span>
       </li>
      </ul>
     </li>
     <li class="listitem">
      <span class="simpara">Para tipos <abbr title="Disjunctive Normal Form">DNF</abbr>:</span>
      <ul class="itemizedlist">
       <li class="listitem">
        <span class="simpara">
         Se um tipo mais genérico for usado, o mais restritivo será redundante.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         Usando dois tipos de interseção idênticos.
        </span>
       </li>
      </ul>
     </li>
    </ul>
   </p>

   <blockquote class="note"><p><strong class="note">Nota</strong>: 
    <span class="simpara">
     Isso não garante que o tipo seja “mínimo”, porque isso exigiria o
     carregamento de todos os tipos de classe usados.
    </span>
   </p></blockquote>

   <p class="para">
    Por exemplo, se <code class="literal">A</code> e <code class="literal">B</code> são aliases de
    classe, <code class="literal">A|B</code> continua sendo um tipo de união legal, mesmo
    que possa ser reduzido a <code class="literal">A</code> ou
    <code class="literal">B</code>.
    Da mesma forma, se a classe <code class="code">B extends A {}</code>, <code class="literal">A|B</code>
    também é um tipo de união legal, embora pudesse ser reduzida a apenas
    <code class="literal">A</code>.

    <div class="informalexample">
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">int</span><span style="color: #007700">|</span><span style="color: #0000BB">INT </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Proibido<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">bool</span><span style="color: #007700">|</span><span style="color: #0000BB">false </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Proibido<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">int</span><span style="color: #007700">&amp;</span><span style="color: #0000BB">Traversable </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Proibido<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">self</span><span style="color: #007700">&amp;</span><span style="color: #0000BB">Traversable </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Proibido<br /><br /></span><span style="color: #007700">use </span><span style="color: #0000BB">A </span><span style="color: #007700">as </span><span style="color: #0000BB">B</span><span style="color: #007700">;<br />function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">A</span><span style="color: #007700">|</span><span style="color: #0000BB">B </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Não permitido ("use" faz parte da resolução de nomes)<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">A</span><span style="color: #007700">&amp;</span><span style="color: #0000BB">B </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Não permitido ("use" faz parte da resolução de nomes)<br /><br /></span><span style="color: #0000BB">class_alias</span><span style="color: #007700">(</span><span style="color: #DD0000">'X'</span><span style="color: #007700">, </span><span style="color: #DD0000">'Y'</span><span style="color: #007700">);<br />function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">X</span><span style="color: #007700">|</span><span style="color: #0000BB">Y </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Permitido (a redundância só é conhecida em tempo de execução)<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">foo</span><span style="color: #007700">(): </span><span style="color: #0000BB">X</span><span style="color: #007700">&amp;</span><span style="color: #0000BB">Y </span><span style="color: #007700">{} </span><span style="color: #FF8000">// Permitido (a redundância só é conhecida em tempo de execução)<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

    </div>
   </p>
  </div>
 </div>

 <div class="sect2" id="language.types.declarations.examples">
  <h3 class="title">Exemplos</h3>
  <div class="example" id="example-77">
   <p><strong>Exemplo #3 Declaração de tipo de classe básica</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">C </span><span style="color: #007700">{}<br />class </span><span style="color: #0000BB">D </span><span style="color: #007700">extends </span><span style="color: #0000BB">C </span><span style="color: #007700">{}<br /><br /></span><span style="color: #FF8000">// Isso não estende C.<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">E </span><span style="color: #007700">{}<br /><br />function </span><span style="color: #0000BB">f</span><span style="color: #007700">(</span><span style="color: #0000BB">C $c</span><span style="color: #007700">) {<br />    echo </span><span style="color: #0000BB">get_class</span><span style="color: #007700">(</span><span style="color: #0000BB">$c</span><span style="color: #007700">).</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">C</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">D</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">E</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>Saída do exemplo acima no PHP 8:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
C
D

Fatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
</pre></div>
   </div>
  </div>

  <div class="example" id="example-78">
   <p><strong>Exemplo #4 Declaração de tipo de interface básica</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">interface </span><span style="color: #0000BB">I </span><span style="color: #007700">{ public function </span><span style="color: #0000BB">f</span><span style="color: #007700">(); }<br />class </span><span style="color: #0000BB">C </span><span style="color: #007700">implements </span><span style="color: #0000BB">I </span><span style="color: #007700">{ public function </span><span style="color: #0000BB">f</span><span style="color: #007700">() {} }<br /><br /></span><span style="color: #FF8000">// Isso não implementa I.<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">E </span><span style="color: #007700">{}<br /><br />function </span><span style="color: #0000BB">f</span><span style="color: #007700">(</span><span style="color: #0000BB">I $i</span><span style="color: #007700">) {<br />    echo </span><span style="color: #0000BB">get_class</span><span style="color: #007700">(</span><span style="color: #0000BB">$i</span><span style="color: #007700">).</span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">C</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">E</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>Saída do exemplo acima no PHP 8:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
C

Fatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
</pre></div>
   </div>
  </div>

  <div class="example" id="example-79">
   <p><strong>Exemplo #5 Declaração de tipo de retorno básico</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">$a</span><span style="color: #007700">, </span><span style="color: #0000BB">$b</span><span style="color: #007700">): </span><span style="color: #0000BB">float </span><span style="color: #007700">{<br />    return </span><span style="color: #0000BB">$a </span><span style="color: #007700">+ </span><span style="color: #0000BB">$b</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #FF8000">// Observe que um float será retornado.<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">2</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
float(3)
</pre></div>
   </div>
  </div>

  <div class="example" id="example-80">
   <p><strong>Exemplo #6 Retornando um objeto</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">C </span><span style="color: #007700">{}<br /><br />function </span><span style="color: #0000BB">getC</span><span style="color: #007700">(): </span><span style="color: #0000BB">C </span><span style="color: #007700">{<br />    return new </span><span style="color: #0000BB">C</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">getC</span><span style="color: #007700">());<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
object(C)#1 (0) {
}
</pre></div>
   </div>
  </div>

  <div class="example" id="example-81">
   <p><strong>Exemplo #7 Declaração de tipo de argumento anulável</strong></p>
   <div class="example-contents">
    <div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">C </span><span style="color: #007700">{}<br /><br />function </span><span style="color: #0000BB">f</span><span style="color: #007700">(?</span><span style="color: #0000BB">C $c</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$c</span><span style="color: #007700">);<br />}<br /><br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(new </span><span style="color: #0000BB">C</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">f</span><span style="color: #007700">(</span><span style="color: #0000BB">null</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
   <div class="example-contents screen">
    <div class="cdata"><pre>
object(C)#1 (0) {
}
NULL
</pre></div>
   </div>
  </div>

  <div class="example" id="example-82">
   <p><strong>Exemplo #8 Declaração de tipo de retorno anulável</strong></p>
   <div class="example-contents">
    <div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">get_item</span><span style="color: #007700">(): ?</span><span style="color: #0000BB">string </span><span style="color: #007700">{<br />    if (isset(</span><span style="color: #0000BB">$_GET</span><span style="color: #007700">[</span><span style="color: #DD0000">'item'</span><span style="color: #007700">])) {<br />        return </span><span style="color: #0000BB">$_GET</span><span style="color: #007700">[</span><span style="color: #DD0000">'item'</span><span style="color: #007700">];<br />    } else {<br />        return </span><span style="color: #0000BB">null</span><span style="color: #007700">;<br />    }<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

  </div>
 </div>

  
 <div class="sect2" id="language.types.declarations.strict">
  <h3 class="title">Tipagem estrita</h3>

  <p class="para">
   Por padrão, o PHP forçará valores do tipo errado na declaração de tipo
   escalar esperada, se possível. Por exemplo, uma função que recebe
   um <span class="type">int</span> para um parâmetro que espera uma <span class="type">string</span>
   obterá uma variável do tipo <span class="type">string</span>.
  </p>

  <p class="para">
   É possível ativar o modo estrito por arquivo. No modo estrito,
   apenas um valor correspondente exatamente à declaração do tipo será
   aceito, caso contrário, um <span class="classname"><a href="class.typeerror.html" class="classname">TypeError</a></span> será lançado.
   A única exceção a essa regra é que um valor <span class="type">int</span> passará por
   uma declaração do tipo <span class="type">float</span>.
  </p>

  <div class="warning"><strong class="warning">Aviso</strong>
   <p class="simpara">
    Chamadas de função dentro de funções internas não serão afetadas pela
    declaração <code class="literal">strict_types</code>.
   </p>
  </div>

  <p class="para">
   Para habilitar o modo estrito, a <a href="control-structures.declare.html" class="link"><code class="literal">declare</code></a> é usada com a
   declaração <code class="literal">strict_types</code>:
  </p>

  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   <p class="para">
    A digitação estrita se aplica a chamadas de função feitas de
    <em class="emphasis">dentro</em> do arquivo com tipagem estrita habilitada, não para
    as funções declaradas dentro desse arquivo. Se um arquivo sem tipagem
    estrita habilitada fizer uma chamada para uma função que foi definida em um arquivo
    com tipagem estrita, a preferência do chamador (tipagem coercitiva) será
    respeitada e o valor será convertido.
   </p>
  </p></blockquote>

  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   <p class="para">
    A tipagem estrita é definida apenas para declarações de tipo escalar.
   </p>
  </p></blockquote>

  <div class="example" id="example-83">
   <p><strong>Exemplo #9 Tipagem estrita para valores de argumentos</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">declare(</span><span style="color: #0000BB">strict_types</span><span style="color: #007700">=</span><span style="color: #0000BB">1</span><span style="color: #007700">);<br /><br />function </span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">int $a</span><span style="color: #007700">, </span><span style="color: #0000BB">int $b</span><span style="color: #007700">) {<br />    return </span><span style="color: #0000BB">$a </span><span style="color: #007700">+ </span><span style="color: #0000BB">$b</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">2</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1.5</span><span style="color: #007700">, </span><span style="color: #0000BB">2.5</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>Saída do exemplo acima no PHP 8:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
int(3)

Fatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
</pre></div>
   </div>
  </div>

  <div class="example" id="example-84">
   <p><strong>Exemplo #10 Tipagem coercitiva para valores de argumento</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">int $a</span><span style="color: #007700">, </span><span style="color: #0000BB">int $b</span><span style="color: #007700">) {<br />    return </span><span style="color: #0000BB">$a </span><span style="color: #007700">+ </span><span style="color: #0000BB">$b</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">2</span><span style="color: #007700">));<br /><br /></span><span style="color: #FF8000">// Estes serão convertidos em números inteiros: observe a saída abaixo!<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1.5</span><span style="color: #007700">, </span><span style="color: #0000BB">2.5</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
int(3)
int(3)
</pre></div>
   </div>
  </div>

  <div class="example" id="example-85">
   <p><strong>Exemplo #11 Tipagem estrita para valores de retorno</strong></p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">declare(</span><span style="color: #0000BB">strict_types</span><span style="color: #007700">=</span><span style="color: #0000BB">1</span><span style="color: #007700">);<br /><br />function </span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">$a</span><span style="color: #007700">, </span><span style="color: #0000BB">$b</span><span style="color: #007700">): </span><span style="color: #0000BB">int </span><span style="color: #007700">{<br />    return </span><span style="color: #0000BB">$a </span><span style="color: #007700">+ </span><span style="color: #0000BB">$b</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">2</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">sum</span><span style="color: #007700">(</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">2.5</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents"><p>O exemplo acima produzirá:</p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
</pre></div>
   </div>
  </div>
 </div>

</div></div></div></body></html>